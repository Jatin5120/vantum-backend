/**
 * STT Service - Resource Cleanup and Memory Management Tests
 * Tests comprehensive resource cleanup to prevent memory leaks
 * Focus: Finalization timeout cleanup, connection close handling, no-leak verification
 * Target Coverage: 90%+ for cleanup paths, 100% for critical resource handles
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { sttService } from '@/modules/stt/services/stt.service';
import { sttSessionService } from '@/modules/stt/services/stt-session.service';
import { STTSession } from '@/modules/stt/services/stt-session.service';
import { LiveTranscriptionEvents } from '@deepgram/sdk';
import { TIMEOUT_CONFIG } from '@/modules/stt/config';

// ============================================================================
// MOCK SETUP
// ============================================================================

let mockEventHandlers = new Map<string, Function[]>();

const createMockLiveClient = () => {
  const handlers = new Map<string, Function[]>();

  return {
    on: vi.fn((event: string, handler: Function) => {
      if (!handlers.has(event)) {
        handlers.set(event, []);
      }
      handlers.get(event)!.push(handler);
    }),

    send: vi.fn(),

    requestClose: vi.fn(),

    removeListener: vi.fn((event: string, handler: Function) => {
      const eventHandlers = handlers.get(event);
      if (eventHandlers) {
        const index = eventHandlers.indexOf(handler);
        if (index > -1) {
          eventHandlers.splice(index, 1);
        }
      }
    }),

    removeAllListeners: vi.fn(() => {
      handlers.clear();
    }),

    getReadyState: vi.fn(() => 1),

    keepAlive: vi.fn(),

    _getHandlers: () => handlers,
  };
};

let currentMockClient: any;

vi.mock('@deepgram/sdk', () => {
  return {
    createClient: vi.fn(() => {
      currentMockClient = createMockLiveClient();
      return {
        listen: {
          live: vi.fn(() => currentMockClient),
        },
      };
    }),
    LiveTranscriptionEvents: {
      Open: 'Open',
      Close: 'Close',
      Transcript: 'Transcript',
      Metadata: 'Metadata',
      Error: 'Error',
      SpeechStarted: 'SpeechStarted',
      UtteranceEnd: 'UtteranceEnd',
    },
  };
});

// ============================================================================
// TEST SUITE
// ============================================================================

describe('STT Service - Resource Cleanup and Memory Management', () => {
  const testSessionId = 'resource-cleanup-test';
  const testConnectionId = 'conn-resource-test';
  const testConfig = {
    sessionId: testSessionId,
    connectionId: testConnectionId,
    samplingRate: 16000,
    language: 'en-US',
  };

  beforeEach(async () => {
    vi.clearAllMocks();
    vi.useFakeTimers();
    await sttService.shutdown({ restart: true });
  });

  afterEach(async () => {
    vi.runAllTimers();
    vi.useRealTimers();
    await sttService.shutdown({ restart: true });
  });

  // ========================================================================================
  // SECTION 1: FINALIZATION TIMEOUT CLEANUP
  // ========================================================================================

  describe('Finalization Timeout Handle Cleanup', () => {
    it('should initialize finalization timeout handle as undefined', async () => {
      // Arrange
      await sttService.createSession(testSessionId, testConfig);
      const session = sttSessionService.getSession(testSessionId);

      // Assert
      expect(session!.finalizationTimeoutHandle).toBeUndefined();
    });

    it('should set finalization timeout during finalization', async () => {
      // Arrange
      await sttService.createSession(testSessionId, testConfig);
      const session = sttSessionService.getSession(testSessionId);
      session!.addTranscript('test', 0.95, true);

      let metadataHandler: Function | null = null;
      currentMockClient.on.mockImplementation((event: string, handler: Function) => {
        if (event === LiveTranscriptionEvents.Metadata) {
          metadataHandler = handler;
        }
      });

      // Act: Start finalization
      const promise = sttService.finalizeTranscript(testSessionId);

      // Assert: Handle set during finalization
      expect(session!.finalizationTimeoutHandle).toBeDefined();

      // Cleanup
      vi.advanceTimersByTime(10);
      if (metadataHandler) {
        metadataHandler({ duration: 1.0 });
      }
      await promise;
      vi.advanceTimersByTime(150);
    });

    it('should clear finalization timeout handle after reset', async () => {
      // Arrange
      await sttService.createSession(testSessionId, testConfig);
      const session = sttSessionService.getSession(testSessionId);
      session!.addTranscript('test', 0.95, true);

      let metadataHandler: Function | null = null;
      currentMockClient.on.mockImplementation((event: string, handler: Function) => {
        if (event === LiveTranscriptionEvents.Metadata) {
          metadataHandler = handler;
        }
      });

      // Act: Finalize and wait for reset
      const promise = sttService.finalizeTranscript(testSessionId);

      vi.advanceTimersByTime(10);
      if (metadataHandler) {
        metadataHandler({ duration: 1.0 });
      }

      await promise;

      // Before reset delay
      expect(session!.finalizationTimeoutHandle).toBeDefined();

      // After reset delay
      vi.advanceTimersByTime(TIMEOUT_CONFIG.FINALIZATION_RESET_DELAY_MS + 10);

      // Assert: Handle cleared
      expect(session!.finalizationTimeoutHandle).toBeUndefined();
    });

    it('should clear existing timeout before setting new one', async () => {
      // Arrange
      await sttService.createSession(testSessionId, testConfig);
      const session = sttSessionService.getSession(testSessionId);

      // Manually set an old timeout
      const oldTimeout = setTimeout(() => {}, 999);
      session!.finalizationTimeoutHandle = oldTimeout;

      session!.addTranscript('test', 0.95, true);

      const clearTimeoutSpy = vi.spyOn(global, 'clearTimeout');

      let metadataHandler: Function | null = null;
      currentMockClient.on.mockImplementation((event: string, handler: Function) => {
        if (event === LiveTranscriptionEvents.Metadata) {
          metadataHandler = handler;
        }
      });

      // Act
      const promise = sttService.finalizeTranscript(testSessionId);

      // Assert: Old timeout was cleared
      expect(clearTimeoutSpy).toHaveBeenCalledWith(oldTimeout);

      // Cleanup
      vi.advanceTimersByTime(10);
      if (metadataHandler) {
        metadataHandler({ duration: 1.0 });
      }
      await promise;
      vi.advanceTimersByTime(150);
    });

    it('should not leak timeout handles with repeated finalization calls', async () => {
      // Arrange
      await sttService.createSession(testSessionId, testConfig);
      const session = sttSessionService.getSession(testSessionId);

      let metadataHandler: Function | null = null;
      currentMockClient.on.mockImplementation((event: string, handler: Function) => {
        if (event === LiveTranscriptionEvents.Metadata) {
          metadataHandler = handler;
        }
      });

      // Act: Finalize 3 times
      for (let i = 0; i < 3; i++) {
        session!.addTranscript(`test ${i}`, 0.95, true);

        const promise = sttService.finalizeTranscript(testSessionId);

        vi.advanceTimersByTime(10);
        if (metadataHandler) {
          metadataHandler({ duration: 1.0 });
        }

        await promise;
        vi.advanceTimersByTime(150);

        // After each finalization, handle should be cleared
        expect(session!.finalizationTimeoutHandle).toBeUndefined();
      }
    });
  });

  // ========================================================================================
  // SECTION 2: KEEPALIVE INTERVAL CLEANUP
  // ========================================================================================

  describe('KeepAlive Interval Cleanup', () => {
    it('should set KeepAlive interval on connection open', async () => {
      // Arrange & Act
      await sttService.createSession(testSessionId, testConfig);
      const session = sttSessionService.getSession(testSessionId);

      // Assert: KeepAlive interval should be set
      expect(session!.keepAliveInterval).toBeDefined();
    });

    it('should clear KeepAlive interval on session cleanup', async () => {
      // Arrange
      await sttService.createSession(testSessionId, testConfig);
      const session = sttSessionService.getSession(testSessionId);

      const keepAliveInterval = session!.keepAliveInterval;
      expect(keepAliveInterval).toBeDefined();

      // Act
      session!.cleanup();

      // Assert: Interval cleared
      expect(session!.keepAliveInterval).toBeUndefined();
    });

    it('should clear KeepAlive interval on unexpected close', async () => {
      // Arrange
      await sttService.createSession(testSessionId, testConfig);
      const session = sttSessionService.getSession(testSessionId);
      const keepAliveInterval = session!.keepAliveInterval;

      session!.isActive = true;

      let closeHandler: Function | null = null;
      currentMockClient.on.mockImplementation((event: string, handler: Function) => {
        if (event === LiveTranscriptionEvents.Close) {
          closeHandler = handler;
        }
      });

      // Act: Trigger close
      if (closeHandler) {
        closeHandler({ code: 1006 });
      }

      // Assert: Interval cleared
      expect(session!.keepAliveInterval).toBeUndefined();
    });

    it('should not leak intervals with multiple sessions', async () => {
      // Arrange
      const sessions: string[] = [];

      // Act: Create 5 sessions
      for (let i = 0; i < 5; i++) {
        const sessionId = `session-${i}`;
        sessions.push(sessionId);
        await sttService.createSession(sessionId, {
          ...testConfig,
          sessionId,
          connectionId: `conn-${i}`,
        });
      }

      // All should have intervals
      for (const sessionId of sessions) {
        const session = sttSessionService.getSession(sessionId);
        expect(session!.keepAliveInterval).toBeDefined();
      }

      // Act: Close all sessions
      for (const sessionId of sessions) {
        const session = sttSessionService.getSession(sessionId);
        session!.cleanup();
      }

      // Assert: All intervals cleared
      for (const sessionId of sessions) {
        const session = sttSessionService.getSession(sessionId);
        if (session) {
          expect(session.keepAliveInterval).toBeUndefined();
        }
      }
    });
  });

  // ========================================================================================
  // SECTION 3: EVENT LISTENER CLEANUP
  // ========================================================================================

  describe('Event Listener Cleanup', () => {
    it('should remove Metadata listener after finalization event', async () => {
      // Arrange
      await sttService.createSession(testSessionId, testConfig);
      const session = sttSessionService.getSession(testSessionId);
      session!.addTranscript('test', 0.95, true);

      let metadataHandler: Function | null = null;
      currentMockClient.on.mockImplementation((event: string, handler: Function) => {
        if (event === LiveTranscriptionEvents.Metadata) {
          metadataHandler = handler;
        }
      });

      // Act
      const promise = sttService.finalizeTranscript(testSessionId);

      vi.advanceTimersByTime(10);
      if (metadataHandler) {
        metadataHandler({ duration: 1.0 });
      }

      await promise;

      // Assert: removeListener was called
      expect(currentMockClient.removeListener).toHaveBeenCalledWith(
        LiveTranscriptionEvents.Metadata,
        expect.any(Function)
      );
    });

    it('should remove Metadata listener on timeout path', async () => {
      // Arrange
      await sttService.createSession(testSessionId, testConfig);
      const session = sttSessionService.getSession(testSessionId);
      session!.addTranscript('test', 0.95, true);

      // Never fire metadata
      currentMockClient.on.mockImplementation(() => {});

      // Act: Finalize and wait for timeout
      const promise = sttService.finalizeTranscript(testSessionId);

      vi.advanceTimersByTime(TIMEOUT_CONFIG.METADATA_EVENT_TIMEOUT_MS + 100);

      await promise;

      // Assert: Still removed listener
      expect(currentMockClient.removeListener).toHaveBeenCalled();
    });

    it('should handle removeListener errors gracefully', async () => {
      // Arrange
      await sttService.createSession(testSessionId, testConfig);
      const session = sttSessionService.getSession(testSessionId);
      session!.addTranscript('test', 0.95, true);

      let metadataHandler: Function | null = null;
      currentMockClient.on.mockImplementation((event: string, handler: Function) => {
        if (event === LiveTranscriptionEvents.Metadata) {
          metadataHandler = handler;
        }
      });

      // Make removeListener throw
      currentMockClient.removeListener.mockImplementation(() => {
        throw new Error('Remove listener error');
      });

      // Act: Should not crash
      const promise = sttService.finalizeTranscript(testSessionId);

      vi.advanceTimersByTime(10);
      if (metadataHandler) {
        metadataHandler({ duration: 1.0 });
      }

      // Assert: Completes without crashing
      await expect(promise).resolves.toBeDefined();
    });
  });

  // ========================================================================================
  // SECTION 4: RECONNECTION BUFFER CLEANUP
  // ========================================================================================

  describe('Reconnection Buffer Cleanup', () => {
    it('should clear reconnection buffer on session cleanup', async () => {
      // Arrange
      const session = new STTSession(testSessionId, testConnectionId, {
        samplingRate: 16000,
        language: 'en-US',
      });

      // Add some data
      session.addToReconnectionBuffer(Buffer.from([1, 2, 3, 4]));
      session.addToReconnectionBuffer(Buffer.from([5, 6, 7, 8]));

      expect(session.reconnectionBuffer.length).toBe(2);

      // Act
      session.cleanup();

      // Assert
      expect(session.reconnectionBuffer.length).toBe(0);
    });

    it('should limit buffer to 32KB total', async () => {
      // Arrange
      const session = new STTSession(testSessionId, testConnectionId, {
        samplingRate: 16000,
        language: 'en-US',
      });

      // Add buffers that exceed 32KB
      const chunk15KB = Buffer.alloc(15 * 1024);
      const chunk15KB2 = Buffer.alloc(15 * 1024);
      const chunk10KB = Buffer.alloc(10 * 1024);

      // Act
      session.addToReconnectionBuffer(chunk15KB);
      session.addToReconnectionBuffer(chunk15KB2);
      session.addToReconnectionBuffer(chunk10KB);

      // Assert: Only last 2 chunks fit
      const totalSize = session.reconnectionBuffer.reduce((sum, buf) => sum + buf.length, 0);
      expect(totalSize).toBeLessThanOrEqual(32 * 1024);
    });

    it('should maintain FIFO order when removing oldest chunks', async () => {
      // Arrange
      const session = new STTSession(testSessionId, testConnectionId, {
        samplingRate: 16000,
        language: 'en-US',
      });

      // Add identifiable chunks
      const chunk1 = Buffer.from([1, 1, 1, 1]);
      const chunk2 = Buffer.from([2, 2, 2, 2]);
      const chunk3 = Buffer.from([3, 3, 3, 3]);

      session.addToReconnectionBuffer(chunk1);
      session.addToReconnectionBuffer(chunk2);

      // Act: Add large chunk that forces removal
      const largeChunk = Buffer.alloc(32 * 1024);
      session.addToReconnectionBuffer(largeChunk);

      // Assert: Oldest chunk removed first
      expect(session.reconnectionBuffer.length).toBeGreaterThan(0);
    });

    it('should return all chunks on flush', async () => {
      // Arrange
      const session = new STTSession(testSessionId, testConnectionId, {
        samplingRate: 16000,
        language: 'en-US',
      });

      const buffers = [
        Buffer.from([1, 2, 3, 4]),
        Buffer.from([5, 6, 7, 8]),
        Buffer.from([9, 10, 11, 12]),
      ];

      for (const buf of buffers) {
        session.addToReconnectionBuffer(buf);
      }

      // Act
      const flushed = session.flushReconnectionBuffer();

      // Assert
      expect(flushed.length).toBe(3);
      expect(session.reconnectionBuffer.length).toBe(0);
    });

    it('should clear all chunks on clearReconnectionBuffer', async () => {
      // Arrange
      const session = new STTSession(testSessionId, testConnectionId, {
        samplingRate: 16000,
        language: 'en-US',
      });

      session.addToReconnectionBuffer(Buffer.from([1, 2, 3, 4]));
      session.addToReconnectionBuffer(Buffer.from([5, 6, 7, 8]));

      // Act
      session.clearReconnectionBuffer();

      // Assert
      expect(session.reconnectionBuffer.length).toBe(0);
    });

    it('should not leak buffer memory with repeated operations', async () => {
      // Arrange
      const session = new STTSession(testSessionId, testConnectionId, {
        samplingRate: 16000,
        language: 'en-US',
      });

      // Act: Many add/flush cycles
      for (let i = 0; i < 10; i++) {
        session.addToReconnectionBuffer(Buffer.from([1, 2, 3, 4]));
        session.addToReconnectionBuffer(Buffer.from([5, 6, 7, 8]));
        session.flushReconnectionBuffer();
      }

      // Assert: Buffer empty
      expect(session.reconnectionBuffer.length).toBe(0);
    });
  });

  // ========================================================================================
  // SECTION 5: COMPLETE SESSION CLEANUP
  // ========================================================================================

  describe('Complete Session Cleanup', () => {
    it('should cleanup all resources on STTSession.cleanup()', async () => {
      // Arrange
      const session = new STTSession(testSessionId, testConnectionId, {
        samplingRate: 16000,
        language: 'en-US',
      });

      // Setup with all resources
      session.keepAliveInterval = setInterval(() => {}, 1000);
      session.finalizationTimeoutHandle = setTimeout(() => {}, 1000);
      session.addToReconnectionBuffer(Buffer.from([1, 2, 3, 4]));

      // Mock client
      session.deepgramLiveClient = {
        requestClose: vi.fn(),
      } as any;

      expect(session.keepAliveInterval).toBeDefined();
      expect(session.finalizationTimeoutHandle).toBeDefined();
      expect(session.reconnectionBuffer.length).toBe(1);

      // Act
      session.cleanup();

      // Assert: All cleaned
      expect(session.keepAliveInterval).toBeUndefined();
      expect(session.finalizationTimeoutHandle).toBeUndefined();
      expect(session.reconnectionBuffer.length).toBe(0);
      expect(session.isActive).toBe(false);
    });

    it('should handle cleanup when client is null', async () => {
      // Arrange
      const session = new STTSession(testSessionId, testConnectionId, {
        samplingRate: 16000,
        language: 'en-US',
      });

      session.deepgramLiveClient = null;

      // Act & Assert: Should not crash
      expect(() => {
        session.cleanup();
      }).not.toThrow();

      expect(session.isActive).toBe(false);
    });

    it('should handle cleanup when client.requestClose() throws', async () => {
      // Arrange
      const session = new STTSession(testSessionId, testConnectionId, {
        samplingRate: 16000,
        language: 'en-US',
      });

      const mockClient = {
        requestClose: vi.fn(() => {
          throw new Error('Close failed');
        }),
      };

      session.deepgramLiveClient = mockClient as any;

      // Act & Assert: Should not crash
      expect(() => {
        session.cleanup();
      }).not.toThrow();

      expect(session.isActive).toBe(false);
    });

    it('should set isActive to false after cleanup', async () => {
      // Arrange
      const session = new STTSession(testSessionId, testConnectionId, {
        samplingRate: 16000,
        language: 'en-US',
      });

      expect(session.isActive).toBe(true);

      // Act
      session.cleanup();

      // Assert
      expect(session.isActive).toBe(false);
    });
  });

  // ========================================================================================
  // SECTION 6: STT SESSION SERVICE CLEANUP
  // ========================================================================================

  describe('STT Session Service Cleanup', () => {
    it('should cleanup all sessions in service', async () => {
      // Arrange
      sttSessionService.createSession('session-1', 'conn-1', {
        samplingRate: 16000,
        language: 'en-US',
      });
      sttSessionService.createSession('session-2', 'conn-2', {
        samplingRate: 16000,
        language: 'en-US',
      });

      expect(sttSessionService.getSessionCount()).toBe(2);

      // Act
      sttSessionService.cleanup();

      // Assert
      expect(sttSessionService.getSessionCount()).toBe(0);
    });

    it('should delete session and call cleanup', async () => {
      // Arrange
      const session = sttSessionService.createSession(testSessionId, testConnectionId, {
        samplingRate: 16000,
        language: 'en-US',
      });

      const cleanupSpy = vi.spyOn(session, 'cleanup');

      // Act
      sttSessionService.deleteSession(testSessionId);

      // Assert: cleanup called
      expect(cleanupSpy).toHaveBeenCalled();
      expect(sttSessionService.getSession(testSessionId)).toBeUndefined();
    });

    it('should handle deletion of non-existent session gracefully', async () => {
      // Act & Assert: Should not crash
      expect(() => {
        sttSessionService.deleteSession('non-existent');
      }).not.toThrow();
    });

    it('should return empty array when no sessions exist', async () => {
      // Arrange
      sttSessionService.cleanup();

      // Act
      const sessions = sttSessionService.getAllSessions();

      // Assert
      expect(sessions).toEqual([]);
    });
  });

  // ========================================================================================
  // SECTION 7: CONCURRENT SESSION CLEANUP
  // ========================================================================================

  describe('Concurrent Session Cleanup', () => {
    it('should handle cleanup of multiple concurrent sessions', async () => {
      // Arrange: Create 5 sessions
      const sessionIds: string[] = [];
      for (let i = 0; i < 5; i++) {
        const sessionId = `concurrent-${i}`;
        sessionIds.push(sessionId);
        await sttService.createSession(sessionId, {
          ...testConfig,
          sessionId,
          connectionId: `conn-${i}`,
        });
      }

      // All should exist
      for (const sessionId of sessionIds) {
        expect(sttSessionService.getSession(sessionId)).toBeDefined();
      }

      // Act: Finalize all concurrently
      const promises = sessionIds.map((id) => sttService.finalizeTranscript(id));

      vi.advanceTimersByTime(10);

      await Promise.all(promises);

      vi.advanceTimersByTime(150);

      // Assert: All cleaned
      for (const sessionId of sessionIds) {
        const session = sttSessionService.getSession(sessionId);
        if (session) {
          expect(session.finalizationTimeoutHandle).toBeUndefined();
        }
      }
    });

    it('should handle concurrent cleanup of sessions', async () => {
      // Arrange: Create 5 sessions
      const sessions: STTSession[] = [];
      for (let i = 0; i < 5; i++) {
        const session = sttSessionService.createSession(`session-${i}`, `conn-${i}`, {
          samplingRate: 16000,
          language: 'en-US',
        });
        sessions.push(session);
      }

      // Act: Cleanup all
      sessions.forEach((session) => session.cleanup());

      // Assert
      expect(sttSessionService.getSessionCount()).toBe(5); // Still in service map
      sessions.forEach((session) => {
        expect(session.isActive).toBe(false);
        expect(session.keepAliveInterval).toBeUndefined();
      });
    });
  });
});
